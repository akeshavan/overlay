
        

     
     <html lang="en">
       <head>
         <title>three.js webgl - loaders - vtk loader</title>
 
         <meta charset="utf-8">
         <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
 
         <style>
     		html, body {
     		  background-color:#000;
     		  margin: 0;
     		  padding: 0;
     		  overflow: hidden !important;  
     		}
     		
     		div{
         		width: 100%;
     		}
	
     	</style>   
         
         <body ng-app="visApp">

            

             <script src="three.min.js"></script>
             <script src="VTKLoader.js"></script>
             <script src="TrackballControls.js"></script>
             <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.js"></script>
             <script src="https://rawgit.com/dataarts/dat.gui/master/build/dat.gui.min.js"></script>

             <script>
             //if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

                 var stats;

                 var camera, controls, scene, renderer;

                 var cross;

                 var objects = [];

                 meshes = [];
                 gui = new dat.GUI()
                 var screenshot = { "Capture Image":function(){ window.open(renderer.domElement.toDataURL("image/png", "final")) }};

                 gui.add(screenshot,'Capture Image');
                 
				
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				var MeshOpts =  {

                  "freesurfer_curvature.vtk":{  
                      filename: "vertices.csv",
                      colormin: "#0000FF", 
                      colormax: "#FF0000",
                      vmin: 2,
                      vmax: 5,
                      key: "freesurfer thickness",
                      key_options: ["freesurfer thickness", "freesurfer curvature", "area", "freesurfer convexity (sulc)", "geodesic depth", "mean curvature", "travel depth"],    
                      threshold: 2.4,
                      mesh_transparency: 1,
                      mesh_visible: true,
                      overlay_transparency: 1
                  },
                  "rh_freesurfer_curvature.vtk":{  
                      filename: "rh_vertices.csv",
                      colormin: "#0000FF", 
                      colormax: "#FF0000",
                      vmin: 2,
                      vmax: 5,
                      key: "freesurfer thickness",
                      key_options: ["freesurfer thickness", "freesurfer curvature", "area", "freesurfer convexity (sulc)", "geodesic depth", "mean curvature", "travel depth"],    
                      threshold: 2.4,
                      mesh_transparency: 1,
                      mesh_visible: true,
                      overlay_transparency: 1
                  },
                  
                };
                
                var initialize_gui = function(mesh){
                    //var gui = new dat.GUI();
                    var meshgui = gui.addFolder(mesh.name);
                    var tmp = mesh.anisha_opts
                    var colormin = gui.addColor(tmp, 'colormin');
                    var colormax = gui.addColor(tmp, 'colormax');
                    var vmin = gui.add(tmp, 'vmin');
                    var vmax = gui.add(tmp, 'vmax');
                    var threshold = gui.add(tmp, 'threshold', 0, 5);
                    var key = gui.add(tmp, "key", tmp.key_options)
                    var mesh_transparency = gui.add(tmp, "mesh_transparency", 0, 1)
                    var mesh_visible = gui.add(tmp, "mesh_visible")
                    
                    var changer = function(value){
                        // console.log("this is", this)
                        // console.log("mesh is", mesh)
                        
                        mesh.anisha_opts = this.object   
                        // console.log(mesh.anisha_opts)
                        color_brain(mesh)
                    }
                    
                    colormin.onChange(changer)
                    colormax.onChange(changer)
                    vmin.onChange(changer)
                    vmax.onChange(changer)
                    key.onChange(changer)
                    threshold.onChange(changer)
                    mesh_transparency.onChange(changer)
                    mesh_visible.onChange(changer)
                    gui.open();

                    
                
                }
				

                // Use CSV is a function that will remember csvs by filenames.  This will only
                // go and get the file if the data for that particular filename has not yet been loaded.
                var useCSV = (function(){
                    var collectionOfCSVs = {};
                    // Cache CSVs by their filename as they are loaded and call the callback function on
                    // the csv data if/once loaded.

                    return function(filename, callback){

                        // if the csv data by this filename already exists...
                        if (collectionOfCSVs[filename]){

                            // use it
                            callback(collectionOfCSVs[filename]);

                        } else {
                            d3.csv(filename, function(csv){
                                // remember the data for this new csv
                                collectionOfCSVs[filename] = csv;

                                // use the csv data
                                callback(csv)
                            })
                        }
                    }

                })();


                // use mesh data and csv data to calculate and cache face_metrics for all possible
                // keys on the faceMetrics argument.
                var calculateFaceMetrics = function(mesh, callback){
                    var mesh_options = mesh.anisha_opts
                    var csv_filename = mesh_options["filename"]
                    var keys = mesh_options.key_options;

                    if(!mesh.face_metrics){
                        mesh.face_metrics = {}
                    }

                    useCSV(csv_filename, function(csv){
                        keys.forEach(function(key, index){
                            if(mesh.face_metrics[key]){
                                return;
                            }

                            mesh.face_metrics[key] = mesh.geometry.faces.map(function(element, index){
                                var vals = parseFloat(csv[element["a"]][key]) + parseFloat(csv[element["b"]][key]) + parseFloat(csv[element["c"]][key])
                                //vals is the average value of the "key"(travel depth, geodesic depth, etc) for the 3 vertices of the face
                                // anisha: I have no idea if this is the right thing to do
                                return vals/3;
                            });

                        });

                        if(typeof callback === 'function'){
                            callback(mesh);
                        }
                    });
                }


                // Color brain depends on face_metrics being calculated once on initialization.
                // This means that on change from the gui, color brain will only be going over each
                // of the faces in the geometry and looking up what color it should set that face to.
                // 
                // Before, the csv was being reloaded each time and the face_metrics was recalculated each time.
				var color_brain = function(mesh){
                    var mesh_options = mesh.anisha_opts
                    var key = mesh_options.key
                    var face_metrics = mesh.face_metrics[key]

                    mesh.material.transparent = true
                    mesh.material.opacity = mesh_options.mesh_transparency
                    mesh.visible = mesh_options.mesh_visible

                    var colorgrad = d3.scale.linear()
                        .domain([mesh_options.vmin, mesh_options.vmax])//[_.min(face_metrics), _.max(face_metrics)])
                        .range([mesh_options.colormin, mesh_options.colormax]);

                    mesh.geometry.faces.forEach(function(element, index){

                        if (face_metrics[index] > mesh_options.threshold){
                            var col = new THREE.Color(colorgrad(face_metrics[index]))
                            element.color.setRGB(col.r, col.g, col.b)
                        } else {
                            // Undo the color setting by setting it back to white.
                            element.color.setRGB(1, 1, 1)
                        }

                    })
                    mesh.geometry.colorsNeedUpdate = true
                }

   			  	function init(){
     	        console.log(window.innerWidth,window.innerHeight);
     	        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
     	        camera.position.z = 120;

     	        controls = new THREE.TrackballControls( camera, container );

     	        controls.rotateSpeed = 5.0;
     	        controls.zoomSpeed = 5;
     	        controls.panSpeed = 2;

     	        controls.noZoom = false;
     	        controls.noPan = false;

     	        controls.staticMoving = true;
     	        controls.dynamicDampingFactor = 0.3;

     	        scene = new THREE.Scene();

     	        scene.add( camera );

     	        // light

     	        var dirLight = new THREE.DirectionalLight( 0xffffff );
     	        dirLight.position.set( 200, 200, 1000 ).normalize();

     	        camera.add( dirLight );
     	        camera.add( dirLight.target );

     	        var material = new THREE.MeshLambertMaterial( { color:0xffffff, side: THREE.DoubleSide } );

     	        var loader = new THREE.VTKLoader();
                 
                var loadMesh = function(name) {
                 					var oReq = new XMLHttpRequest();
                 					oReq.open("GET", name, true);
                 					oReq.onload = function(oEvent) {
                 						var buffergeometry=new THREE.VTKLoader().parse(this.response);
					
                 						geometry=new THREE.Geometry().fromBufferGeometry(buffergeometry);
                 						geometry.computeFaceNormals();
                 						geometry.computeVertexNormals();
                 						geometry.__dirtyColors = true;
							
                 						material=new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors});
                 						// var color = [Math.random(), Math.random(), Math.random()]
						    			//console.log("hello")
                 						/*for (i=0;i<geometry.faces.length;i++){
                 							var face = geometry.faces[i];
                 							face.color.setHex( Math.random() * 0xffffff );
                 							//face.color.setRGB(color[0],color[1],color[2]);
						
                 							//face.materials = [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ];
                 						}
                 						geometry.colorsNeedUpdate = true*/
                 						mesh=new THREE.Mesh(geometry,material);
                 						mesh.dynamic=true
                 						mesh.name = name
                 						//mesh.name = name
										
                 				        mesh.rotation.y = Math.PI * 1.1;
 		                                mesh.rotation.x = Math.PI * 0.5;
 		                                mesh.rotation.z = Math.PI * 1.5;
 		                                mesh.anisha_opts = MeshOpts[mesh.name]
	
                                        // calculate face_metrics once, and after calculations for all
                                        // keys are done, color brain.
                                        calculateFaceMetrics(mesh, color_brain)
                                        initialize_gui(mesh)
                                        
                 						
                 						scene.add(mesh);
                 						meshes.push(mesh)
					
                 					}
                 					oReq.send();
                 			}
                 				
                 
                console.log("loading meshes")
                files_to_load = Object.keys(MeshOpts)
                
                 for (i=0;i<files_to_load.length;i++){
                    loadMesh(files_to_load[i])	
					console.log("loaded mesh",i)
					                 }

        
     	        // renderer

     			renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
     			 
     	        renderer.setPixelRatio( window.devicePixelRatio );
     	        renderer.setSize( window.innerWidth, window.innerHeight);
				container.appendChild( renderer.domElement );
				}
				
			    
     	        //window.addEventListener( 'resize', onWindowResize, false );
          
             	var animate = function() {

             	        requestAnimationFrame( animate );

             	        controls.update();
             	        renderer.render( scene, camera );
						//console.log("rendered")
	
             	      }
                       
				init();

                 
                console.log("finished init")
                 
                
                //var meshgui = gui.addFolder('Mesh');
                

                
                
                
                
             animate();
             
             </script>

           </body>
         </html>

     
  
        